# moved from sae.basic.views.py on 20181113
import logging, os, datetime, sys
import psutil  #, numpy

from django.shortcuts import render
from django.http import JsonResponse
from django.views.generic import TemplateView
from django.conf import settings as django_settings
from django.utils.log import configure_logging
from django.utils.translation import gettext_lazy as _

from sae import settings
from sae.basic.models import Image, ImageRecognitionSequene, SynsetWords
from sae.basic.utils import Util
from sae.extend.baidu import BaiduTranslation
# called by Linux Crontab daily for creating log files
class DailyCrontabView(TemplateView):
	template_name = 'basic_daily.html'

	def get(self, request, *args, **kwargs):
		# create log files for today
		# log_files = ['rotating', 'request', 'template', 'db', 'security', ]
		# changed = False
		# for file_name in log_files:
		# 	file_path = os.path.join( settings.BASE_DIR, 'sae/temporary/' ) + datetime.datetime.now().strftime('%Y%m%d') + file_name + '.log'
		# 	if not os.path.isfile( file_path ):
		# 		temp = file_name + '_file'
		# 		settings.LOGGING['handlers'][temp] = file_path
		# 		changed = True
		# if changed:
			# configure_logging(django_settings.LOGGING_CONFIG, settings.LOGGING)
		# Debug conclusion: cannot make any changes here. Because right after the server started, 
		# the logging.config.dictConfig(config) should be locked and should not be changed 
		# inside views.py in apps. Otherwise bugs will emerge.

		# also for the reason above, comment out lines below:
		# delete yesterday's empty log files
		# yesterday_log_files = log_files
		# yesterday_log_files.append('debug_server')
		# today = datetime.date.today() 
		# oneday = datetime.timedelta(days=1) 
		# yesterday = today - oneday
		# for file_name in yesterday_log_files:
		# 	file_path = os.path.join( settings.BASE_DIR, 'sae/temporary/' ) + yesterday.strftime('%Y%m%d') + file_name + '.log'
		# 	if os.path.isfile( file_path ) and 0 == os.path.getsize( file_path ):
		# 		os.remove( file_path )

		# labels_file = 'D:\\synset_words.txt'
		# labels = numpy.loadtxt(labels_file, str, delimiter='\t')
		# for key, value in enumerate(labels):
		# 	temp = value.split(' ', 1)
		# 	temp_array = temp[1].split(', ')
		# 	new_dict = {}
		# 	for word in temp_array:
		# 		obj = BaiduTranslation(text=word)
		# 		code, string = obj.request_baidu()
		# 		if 200 == code:
		# 			new_dict[word] = string
		# 		else:
		# 			print(code)
		# 			print(string)
		# 			break
			# string = str(key) + ' => ' + temp[0]
			# if 9 != len(temp[0]):
			# 	string += '(' + str(len(temp[0])) + ')'
			# string += ' : ' + str(len(temp_array)) + ' : ' + str(new_dict)
			# print( string )
			#### SynsetWords.objects.create(serial_key=temp[0], label=str(new_dict))
			# if 3 < key:
			# 	break
		# word = SynsetWords.objects.get(pk=1)
		# print( eval(word.label) )
		variables = {
			'page_title': _('internal action'),
		}
		return render( request, self.template_name, variables )

class MinuteCrontabView(TemplateView):
	template_name = 'basic_minute.html'
	# caffe_root = os.path.join( '/local/', 'caffe/' )

	def get(self, request, *args, **kwargs):
		# read the sequene table for image recognition
		file_name = ''
		variables = {
			'response_code': 403,
			'response_content': 'invalid token',
			'file_name': file_name,
		}
		response_code = '400:'
		if 'token' not in self.kwargs.keys() or self.kwargs['token'] is None:
			return JsonResponse(variables)
		if not Util.validateToken(Util, self.kwargs['token'] ):
			# print( self.kwargs['token'] )
			return JsonResponse(variables)
		if 'goal' in self.kwargs.keys() and 0 < int( self.kwargs['goal'] ):
			goal = int( self.kwargs['goal'] )
			# print( 'goal = ', goal)
			if 1 == goal:
				# get the first image for recognizing
				next_image = ImageRecognitionSequene.objects.order_by('sequene_id').first()
				if next_image is None:
					response_code = '404: no image file in the sequene'
				else:
					response_code = '200: pushed the image file into the sequene for recognition'
					file_name = next_image.file_name
			elif 2 == goal:
				# get the recognized result from caffe
				if 'result' not in self.kwargs.keys() or 1 > int( self.kwargs['result'] ):
					response_code = '400: need result code'
				elif 'filename' not in self.kwargs.keys() or '' == str( self.kwargs['filename'] ):
					response_code = '400: need image file name'
				else:
					result = int( self.kwargs['result'] )
					file_name = str( self.kwargs['filename'] )
					try:
						this_sequene = ImageRecognitionSequene.objects.filter(file_name__exact=file_name).get()
						if this_sequene is None or not hasattr(this_sequene, 'image') or this_sequene.image is None:
							response_code = '404: no image record found in Image'
						else:
							this_image = this_sequene.image
							# labels_file = self.caffe_root + 'data/ilsvrc12/synset_words.txt'
							# labels = numpy.loadtxt(labels_file, str, delimiter='\t')
							# string_result = labels[result]
							word = SynsetWords.objects.get(pk=1+result)
							this_image.recognized_time = datetime.datetime.now()
							this_image.recognized = word.label # word.label is string
							# eval(word.label) is dictionary
							this_image.save()
							response_code = '200: database updated'
							this_sequene.delete()
					except ImageRecognitionSequene.DoesNotExist as ex:
						response_code = '404: no sequene record found'
			else:
				response_code = '400: goal could be 1 or 2 only'
		else:
			response_code = '400: need parameter goal'

		# render a json string
		temp = response_code.split(':', 1)
		variables = {
			'response_code': int( temp[0] ),
			'response_content': str( temp[1] ),
			'file_name': file_name,
		}
		return JsonResponse(variables)
